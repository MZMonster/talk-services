// Generated by CoffeeScript 1.10.0
(function() {
  var Promise, _, _receiveWebhook, marked, util,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  _ = require('lodash');

  Promise = require('bluebird');

  marked = require('marked');

  util = require('../util');


  /**
   * Define handler when receive incoming webhook from gitlab
   * @param  {Object}   req      Express request object
   * @param  {Function} callback
   * @return {Promise}
   */

  _receiveWebhook = function(arg) {
    var attachment, body, build_duration, build_id, build_name, build_status, color, commit, commitArr, commitUrl, commits, goodStatus, integration, lockKey, message, object_attributes, payload, project_name, ref, repository, self, text;
    integration = arg.integration, body = arg.body;
    self = this;
    payload = body;
    switch (payload.object_kind) {
      case 'build':
        payload.event = 'build';
        break;
      case 'issue':
        payload.event = 'issues';
        break;
      case 'merge_request':
        payload.event = 'merge_request';
        break;
      default:
        payload.event = 'push';
    }
    repository = payload.repository, commits = payload.commits, object_attributes = payload.object_attributes;
    commits || (commits = []);
    message = {};
    attachment = {
      category: 'quote',
      data: {}
    };
    switch (payload.event) {
      case 'push':
        attachment.data.title = "" + (repository != null ? repository.name : void 0);
        if (payload.before === '0000000000000000000000000000000000000000') {
          attachment.data.title += " create branch " + payload.ref;
        } else if (payload.after === '0000000000000000000000000000000000000000') {
          attachment.data.title += " remove branch " + payload.ref;
        } else {
          attachment.data.title += " new commits";
        }
        commitArr = commits.map(function(commit) {
          var authorPrefix, ref1, ref2;
          authorPrefix = (commit != null ? (ref1 = commit.author) != null ? ref1.name : void 0 : void 0) ? " [" + commit.author.name + "] " : " ";
          return "<a href=\"" + commit.url + "\" target=\"_blank\"><code>" + (commit != null ? (ref2 = commit.id) != null ? ref2.slice(0, 6) : void 0 : void 0) + ":</code></a>" + authorPrefix + (commit != null ? commit.message : void 0) + "<br>";
        });
        attachment.data.text = commitArr.join('');
        attachment.data.redirectUrl = repository != null ? repository.homepage : void 0;
        break;
      case 'merge_request':
        attachment.data.title = "[" + (object_attributes != null ? object_attributes.state : void 0) + "] " + (object_attributes != null ? object_attributes.title : void 0);
        attachment.data.text = "" + (marked((object_attributes != null ? object_attributes.description : void 0) || ''));
        break;
      case 'issues':
        attachment.data.title = "[" + (object_attributes != null ? object_attributes.state : void 0) + "] " + (object_attributes != null ? object_attributes.title : void 0);
        attachment.data.text = "" + (marked((object_attributes != null ? object_attributes.description : void 0) || ''));
        break;
      case 'build':
        ref = payload.ref, commit = payload.commit, build_id = payload.build_id, build_name = payload.build_name, repository = payload.repository, build_status = payload.build_status, project_name = payload.project_name, build_duration = payload.build_duration;
        goodStatus = ['success', 'failed', 'canceled'];
        if (indexOf.call(goodStatus, build_status) < 0) {
          return;
        }
        color = (function() {
          switch (build_status) {
            case goodStatus[0]:
              return attachment.color = 'green';
            case goodStatus[1]:
              return attachment.color = 'red';
            case goodStatus[2]:
              return attachment.color = 'yellow';
          }
        })();
        commitUrl = repository.homepage + "/commit/" + commit.sha;
        text = "ref: " + ref + "\ncommit: [" + commit.sha.slice(0, 8) + "](" + commitUrl + ")\nauthor: " + commit.author_name + "\nstatus: " + build_status + "\nduration: " + (Math.round(build_duration)) + "s";
        attachment.data = {
          redirectUrl: commitUrl,
          text: marked(text).trim(),
          title: "Build: " + project_name
        };
    }
    lockKey = "lock:gitlab:" + integration._roomId + ":" + integration._teamId + ":" + integration._id + ":" + payload.event;

    /**
     * @todo Find out the reason why gitlab will post same event and payload more than once
     */
    if (util.isLocked(lockKey)) {
      return;
    }
    util.lock(lockKey, 20000);
    message.attachments = [attachment];
    return message;
  };

  module.exports = function() {
    this.title = 'GitLab';
    this.template = 'webhook';
    this.summary = util.i18n({
      zh: '用于仓库管理系统的开源项目。',
      en: 'GitLab is a web-based Git repository manager with wiki and issue tracking features.'
    });
    this.description = util.i18n({
      zh: 'GitLab 是一个用于仓库管理系统的开源项目，添加后可以收到来自 GitLab 的推送。',
      en: 'GitLab is a software repository manager. You may connect webhooks of GitLab repos.'
    });
    this.iconUrl = util["static"]('images/icons/gitlab@2x.png');
    this._fields.push({
      key: 'webhookUrl',
      type: 'text',
      readOnly: true,
      description: util.i18n({
        zh: '复制 web hook 地址到你的 GitLab 仓库当中使用。你也可以在管理界面当中找到这个 web hook 地址。',
        en: 'Copy this web hook to your GitLab repo to use it. You may also find this url in the manager tab.'
      })
    });
    return this.registerEvent('service.webhook', _receiveWebhook);
  };

}).call(this);
