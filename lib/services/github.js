// Generated by CoffeeScript 1.10.0
(function() {
  var Promise, _, _createHook, _createWebhook, _getEvents, _getGitHubApiHost, _receiveWebhook, _removeHook, _removeWebhook, _updateHook, _updateWebhook, marked, request, requestAsync, util,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  Promise = require('bluebird');

  marked = require('marked');

  _ = require('lodash');

  request = require('request');

  requestAsync = Promise.promisify(request);

  util = require('../util');

  _getGitHubApiHost = function() {
    var ref;
    return ((ref = util.config.github) != null ? ref.apiHost : void 0) || 'https://api.github.com';
  };


  /**
   * Create github hook
   * @param  {String} repos - Repos name
   * @param  {String} token - Token
   * @param  {Array} events - Events of hook
   * @param  {String} hashId - HashId of integration
   * @return {Promise} Response body
   */

  _createHook = function(repos, token, events, hashId) {
    return requestAsync({
      method: 'POST',
      url: (_getGitHubApiHost()) + "/repos/" + repos + "/hooks",
      headers: {
        'User-Agent': util.getUserAgent(),
        'Authorization': "token " + token
      },
      json: true,
      body: {
        name: 'web',
        active: true,
        events: events,
        config: {
          url: util.config.apiHost + "/services/webhook/" + hashId,
          content_type: 'json'
        }
      }
    }).then(function(res) {
      var err;
      if (!(res.statusCode >= 200 && res.statusCode < 300)) {
        err = new Error("Bad request " + res.statusCode);
      }
      if (err) {
        throw err;
      }
      return res.body;
    });
  };


  /**
   * Remove github hook
   * @param  {String} repos - Repos name
   * @param  {String} hookId - The github hook id
   * @param  {String} token - Github user token
   * @return {Promise}
   */

  _removeHook = function(repos, hookId, token) {
    return requestAsync({
      method: 'DELETE',
      url: (_getGitHubApiHost()) + "/repos/" + repos + "/hooks/" + hookId,
      headers: {
        'User-Agent': util.getUserAgent(),
        'Authorization': "token " + token
      },
      json: true
    }).then(function(res) {
      var err;
      if (!(res.statusCode >= 200 && res.statusCode < 300)) {
        err = new Error("bad request " + res.statusCode);
      }
      if (err) {
        throw err;
      }
    })["catch"](function(err) {
      return false;
    });
  };


  /**
   * Update github hook
   * @param  {String} repos - Repos name
   * @param  {String} hookId - Github hook id
   * @param  {String} token - Token
   * @param  {Array} events - Events of hook
   * @param  {String} hashId - hashId of integration
   * @return {Promise} Response body
   */

  _updateHook = function(repos, hookId, token, events, hashId) {
    return requestAsync({
      method: 'PATCH',
      url: (_getGitHubApiHost()) + "/repos/" + repos + "/hooks/" + hookId,
      headers: {
        'User-Agent': util.getUserAgent(),
        'Authorization': "token " + token
      },
      json: true,
      body: {
        name: 'web',
        active: true,
        events: events,
        config: {
          url: util.config.apiHost + "/services/webhook/" + hashId,
          content_type: 'json'
        }
      }
    }).then(function(res) {
      var err;
      if (!(res.statusCode >= 200 && res.statusCode < 300)) {
        err = new Error("bad request " + res.statusCode);
      }
      if (err) {
        throw err;
      }
      return res.body;
    });
  };

  _createWebhook = function(arg) {
    var data, integration, self;
    integration = arg.integration;
    self = this;
    data = {};
    if (integration.url) {
      return;
    }
    return Promise.resolve(integration.repos).map(function(repos) {
      return _createHook(repos, integration.token, integration.events, integration.hashId).then(function(body) {
        var _repos;
        _repos = repos.split('.').join('_');
        return data[_repos] = {
          hookId: body != null ? body.id : void 0
        };
      });
    }).then(function() {
      integration.data = data;
      return integration;
    });
  };

  _removeWebhook = function(arg) {
    var data, integration, reposes, self;
    integration = arg.integration;
    self = this;
    if (integration.url) {
      return;
    }
    reposes = integration.repos;
    data = integration.data || {};
    return Promise.resolve(reposes).map(function(repos) {
      var _repos, hookId, ref;
      _repos = repos.split('.').join('_');
      hookId = (ref = data[_repos]) != null ? ref.hookId : void 0;
      if (!hookId) {
        return;
      }
      return _removeHook(repos, hookId, integration.token);
    });
  };

  _updateWebhook = function(req) {
    var $removeOldRepos, $updateNewRepos, data, events, integration, ref, repos;
    integration = req.integration;
    if (integration.url) {
      return;
    }
    ref = req.get(), events = ref.events, repos = ref.repos;
    if (!((events != null ? events.length : void 0) && (repos != null ? repos.length : void 0))) {
      return;
    }
    data = integration.data || {};
    if (repos && !_.isEqual(repos, integration.repos)) {
      $removeOldRepos = Promise.resolve(integration.repos).map(function(repos) {
        var _repos, hookId, ref1;
        if (indexOf.call(reposes, repos) >= 0) {
          return;
        }
        _repos = repos.split('.').join('_');
        hookId = (ref1 = data[_repos]) != null ? ref1.hookId : void 0;
        if (!hookId) {
          return delete data[_repos];
        }
        return _removeWebhook(repos, hookId, integration.token);
      });
    } else {
      $removeOldRepos = Promise.resolve();
    }
    $updateNewRepos = Promise.resolve(integration.repos).map(function(repos) {
      var _repos, hookId, ref1;
      _repos = repos.split('.').join('_');
      if (_.isEqual(integration.repos, repos)) {
        if (_.isEqual(events, integration.events)) {
          return;
        }
        hookId = (ref1 = data[_repos]) != null ? ref1.hookId : void 0;
        if (!hookId) {
          throw new Error('Github hook not found');
        }
        return _updateHook(repos, hookId, integration.token, events, integration.hashId);
      } else {
        return _createHook(repos, integration.token, events, integration.hashId).then(function(body) {
          return data[_repos] = {
            hookId: body != null ? body.id : void 0
          };
        });
      }
    });
    return Promise.all([$removeOldRepos, $updateNewRepos]).then(function() {
      return integration.data = data;
    });
  };

  _receiveWebhook = function(arg) {
    var action, attachment, body, comment, commitArr, commits, event, forkee, head_commit, headers, integration, issue, message, payload, pull_request, repository, self, sender;
    headers = arg.headers, body = arg.body, integration = arg.integration;
    self = this;
    event = headers['x-github-event'];
    payload = body;
    sender = payload.sender, issue = payload.issue, action = payload.action, comment = payload.comment, repository = payload.repository, forkee = payload.forkee, head_commit = payload.head_commit, commits = payload.commits, pull_request = payload.pull_request;
    message = {};
    attachment = {
      category: 'quote',
      data: {
        userName: sender.login,
        userAvatarUrl: sender.avatar_url
      }
    };
    switch (event) {
      case 'commit_comment':
        attachment.data.title = repository.full_name + " commit comment by " + (sender != null ? sender.login : void 0);
        attachment.data.text = "" + (marked((comment != null ? comment.body : void 0) || ''));
        attachment.data.redirectUrl = comment != null ? comment.html_url : void 0;
        break;
      case 'create':
        attachment.data.title = repository.full_name + " " + payload.ref_type + " " + payload.ref + " created by " + (sender != null ? sender.login : void 0);
        attachment.data.redirectUrl = repository != null ? repository.html_url : void 0;
        break;
      case 'delete':
        attachment.data.title = repository.full_name + " " + payload.ref_type + " " + payload.ref + " deleted by " + (sender != null ? sender.login : void 0);
        attachment.data.redirectUrl = repository != null ? repository.html_url : void 0;
        break;
      case 'fork':
        attachment.data.title = repository.full_name + " forked to " + (forkee != null ? forkee.full_name : void 0);
        attachment.data.redirectUrl = forkee != null ? forkee.html_url : void 0;
        break;
      case 'issue_comment':
        attachment.data.title = repository.full_name + " issue comment by " + (sender != null ? sender.login : void 0);
        attachment.data.text = "" + (marked((comment != null ? comment.body : void 0) || ''));
        attachment.data.redirectUrl = comment != null ? comment.html_url : void 0;
        break;
      case 'issues':
        attachment.data.title = repository.full_name + " issue " + (action || '') + " " + (issue != null ? issue.title : void 0);
        attachment.data.text = marked((issue != null ? issue.body : void 0) || '');
        attachment.data.redirectUrl = issue != null ? issue.html_url : void 0;
        break;
      case 'pull_request':
        attachment.data.title = repository.full_name + " pull request " + (pull_request != null ? pull_request.title : void 0);
        attachment.data.text = marked((pull_request != null ? pull_request.body : void 0) || '');
        attachment.data.redirectUrl = pull_request != null ? pull_request.html_url : void 0;
        break;
      case 'pull_request_review_comment':
        attachment.data.title = repository.full_name + " review comment by " + (sender != null ? sender.login : void 0);
        attachment.data.text = marked((comment != null ? comment.body : void 0) || '');
        attachment.data.redirectUrl = comment != null ? comment.html_url : void 0;
        break;
      case 'push':
        if (!(commits != null ? commits.length : void 0)) {
          return false;
        }
        attachment.data.title = repository.full_name + " commits to " + payload.ref;
        commitArr = commits.map(function(commit) {
          var authorPrefix, ref, ref1;
          authorPrefix = (commit != null ? (ref = commit.committer) != null ? ref.name : void 0 : void 0) ? " [" + commit.committer.name + "] " : " ";
          return "<a href=\"" + commit.url + "\" target=\"_blank\"><code>" + (commit != null ? (ref1 = commit.id) != null ? ref1.slice(0, 6) : void 0 : void 0) + ":</code></a>" + authorPrefix + (commit != null ? commit.message : void 0) + "<br>";
        });
        attachment.data.text = commitArr.join('');
        attachment.data.redirectUrl = head_commit.url;
        break;
      default:
        return false;
    }
    message.attachments = [attachment];
    return message;
  };

  _getEvents = function() {
    return [
      {
        key: 'push',
        label: util.i18n({
          zh: 'Push',
          en: 'Push'
        }),
        title: util.i18n({
          zh: "仓库的 Push, 包括编辑 tag 或者分支. 通过 API 发布的改变了缩印的 commit 也包括在内. 这是默认事件",
          en: "Any Git push to a Repository, including editing tags or branches. Commits via API actions that update references are also counted. This is the default event"
        }),
        checked: true
      }, {
        key: 'commit_comment',
        label: util.i18n({
          zh: 'Commit 被评论',
          en: 'Comment on commit'
        }),
        title: util.i18n({
          en: 'Any time a Commit is commented on'
        })
      }, {
        key: 'create',
        label: util.i18n({
          zh: '创建分支或者 tag',
          en: 'Create branch or tag'
        }),
        title: util.i18n({
          en: 'Any time a Branch or Tag is created'
        })
      }, {
        key: 'delete',
        label: util.i18n({
          zh: '删除分支或者 tag',
          en: 'Delete branch or tag'
        }),
        title: util.i18n({
          en: 'Any time a Branch or Tag is deleted'
        })
      }, {
        key: 'fork',
        label: util.i18n({
          zh: '仓库被 Fork',
          en: 'Fork'
        }),
        title: util.i18n({
          en: 'Any time a Repository is forked'
        })
      }, {
        key: 'issue_comment',
        label: util.i18n({
          zh: 'Issue 被评论',
          en: 'Comment on issue'
        }),
        title: util.i18n({
          en: 'Any time an Issue is commented on'
        })
      }, {
        key: 'issues',
        label: util.i18n({
          zh: 'Issues',
          en: 'Issues'
        }),
        title: util.i18n({
          zh: 'Issue 被指定, 取消指定, 标记, 取消标记, 创建, 关闭, 重新打开',
          en: 'Any time an Issue is assigned, unassigned, labeled, unlabeled, opened, closed, or reopened'
        })
      }, {
        key: 'pull_request_review_comment',
        label: util.i18n({
          zh: 'PR 中增加 Commit',
          en: 'Commit in PR'
        }),
        title: util.i18n({
          zh: 'Pull Request（的文件页面）当中的 Commit 被评论',
          en: 'Any time a Commit is commented on while inside a Pull Request review (the Files Changed tab)'
        })
      }, {
        key: 'pull_request',
        label: util.i18n({
          zh: 'Pull request',
          en: 'Pull request'
        }),
        title: util.i18n({
          zh: 'Pull Request 被指定, 取消指定, 标记, 取消标记, 打开, 关闭, 重新打开, 或者同步（pull request 正在追踪的分支上新的 Push 引起的更新）',
          en: 'Any time a Pull Request is assigned, unassigned, labeled, unlabeled, opened, closed, reopened, or synchronized (updated due to a new push in the branch that the pull request is tracking)'
        })
      }
    ];
  };

  module.exports = function() {
    this.title = 'GitHub';
    this.summary = util.i18n({
      zh: '分布式的版本控制系统。',
      en: 'GitHub offers online source code hosting for Git projects.'
    });
    this.description = util.i18n({
      zh: 'GitHub 是一个分布式的版本控制系统。选择一个话题添加 GitHub 聚合后，你就可以在被评论、创建或删除分支、仓库被 fork 等情形下收到简聊通知。',
      en: 'GitHub offers online source code hosting for Git projects. This integration allows you receive GitHub comments, pull request, etc. '
    });
    this.iconUrl = util["static"]('images/icons/github@2x.png');
    this._fields.push({
      key: 'webhookUrl',
      type: 'text',
      readOnly: true,
      description: util.i18n({
        zh: '请复制您的 Webhook 地址到 GitHub 中使用',
        en: 'Copy and paste your github webhook url'
      })
    });
    this._fields.push({
      key: 'events',
      items: _getEvents.apply(this)
    });
    this.registerEvent('before.integration.create', _createWebhook);
    this.registerEvent('before.integration.update', _updateWebhook);
    this.registerEvent('before.integration.remove', _removeWebhook);
    return this.registerEvent('service.webhook', _receiveWebhook);
  };

}).call(this);
